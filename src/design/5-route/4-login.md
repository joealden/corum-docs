# Login Page

## Client Side

This is the page that the user will see when they visit the path `'/login'`.
This page could be accessed in 2 different ways. The first way would be to
physically type the path into the web browser's url bar. The second way would be
to click on the `login` button located in the header. This page will display a
form to the user to login. For the user to login, they must have first created
an account (Which is done through the `signup` page).

The login form will contain the following:

* The Corum logo
* An email address field
* A password field
* A login button
* A message and link directing the user to the `signup` page if they do not
  already have an account.

The login button will only be enabled (clickable) if both an email address and a
password have been supplied.

If the user successfully logs in, they will be redirected back to the page they
were previously on before visiting the login page. If the user has an
unsuccessful login attempt, then the error returned by the GraphQL API will be
displayed to the user. After the error has been displayed, the user will be free
to try and login again.

After the user logs in, the rest of the site will update in response to the
state change. (From being logged out to being logged in) These state changes are
described in more detail in the [Component Design](#component-design) section.

This means the following:

* The header will render a greeting and logout button instead of the signup and
  login buttons
* The navigation will render the user's 'favorites' section and the 'all
  subforums' section instead of just the 'all subforums' section
* The user will now be allowed to create new posts and comments
* The user will now be allowed to upvote and downvote posts

After the site has updated to be in the 'logged in' state, the user will no
longer be able to click on a login button. However, this does not mean they
could not access the login page from the other way described above, via the url
bar in the browser. If the user could access the login page when already logged
in, this would not only be confusing to the user, it could cause bugs. To
prevent this issue, if a user visits `'/login'` when already logged in, then a
message will display telling them that they are already logged in.

## Server Side

The graphcool framework doesn't provide a user authentication system out of the
box. Instead, I will have to create my own using Graphcool resolvers. As talked
about already, graphcool provides ways to extend its functionality. Resolvers
are one of many extension points that graphcool provides. Resolvers essentially
allow you to create custom GraphQL queries and mutations on top of the
auto-generated CRUD ones such as `allPosts`, `createPost` etc. To find out more
about Graphcool resolvers, visit the graphcool docs here.
([graph.cool/docs](https://www.graph.cool/docs/reference/functions/resolvers-su6wu3yoo2))

To create a user authentication system, the resolver must do the following:

* Expose a GraphQL mutation called `authenticateUser`
* This mutation will have the following inputs and outputs:
  * Inputs:
    * `email` -> type String (The email of the user)
    * `password` -> type String (The password of the user)
  * Outputs:
    * `ID` -> type ID (ids are generated by graphcool and are unique, the users
      ID will be used to determine the state of the UI)
    * `username` -> type String (The username that is associated with the email
      address entered. This is what other users see on posts and comments)
    * `token` -> type String (A JWT (JSON Web Token) that will be stored to be
      later used to authenticate the user when making requests such as to create
      a new post)
* Check if a user with the email provided exists
  * If one does not, then return a generic error to the user saying something
    such as 'Invalid credentials'. (Intentionally vague error message for
    security reasons)
* Now that we have confirmed that the user exists, we can check if the user
  entered the correct password for the user
* Using a password hashing library (probably something like bcryptjs), hash the
  password the user entered and compare the hash with the one stored on the
  server
  * If they do not match, then return the same generic error of 'Invalid
    credentials'
* If the hashes match, then we know that the user has entered both the correct
  email and correct password
* Now we can return the user the data that they requested.

As mentioned briefly above, the `token` output is a JWT (JSON Web Token). JWTs
are extremely useful when dealing with stateless protocols such as HTTP. JWTs
can be used to verify that the client is who they say they are. In an
application such as Corum, users that are not logged in should not be allowed to
create new posts or new comments. By sending the JWT in the header of every HTTP
request to the GraphQL API, I can ensure that only logged in users can perform
actions such as creating new posts and comments. To find out more about JWTs,
visit the following link. ([jwt.io](https://jwt.io/))

Some of this will only make complete sense after reading through how Corum will
create the users in the first place. This is described in the section below.
